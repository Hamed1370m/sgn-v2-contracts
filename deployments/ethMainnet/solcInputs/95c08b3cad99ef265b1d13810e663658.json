{
  "language": "Solidity",
  "sources": {
    "contracts/libraries/Utils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nlibrary Utils {\n    // https://ethereum.stackexchange.com/a/83577\n    // https://github.com/Uniswap/v3-periphery/blob/v1.0.0/contracts/base/Multicall.sol\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}\n"
    },
    "contracts/safeguard/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\n * This adds a normal func that setOwner if _owner is address(0). So we can't allow\n * renounceOwnership. So we can support Proxy based upgradable contract\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Only to be called by inherit contracts, in their init func called by Proxy\n     * we require _owner == address(0), which is only possible when it's a delegateCall\n     * because constructor sets _owner in contract state.\n     */\n    function initOwner() internal {\n        require(_owner == address(0), \"owner already set\");\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/safeguard/sentinel/Guard.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.17;\n\nimport \"../Ownable.sol\";\n\nabstract contract Guard is Ownable {\n    enum GuardState {\n        None,\n        Guarded,\n        Relaxed\n    }\n\n    bool public relaxed;\n    uint256 public numRelaxedGuards;\n    uint256 public relaxThreshold;\n    address[] public guards;\n    mapping(address => GuardState) public guardStates; // guard address -> guard state\n\n    event GuardUpdated(address account, GuardState state);\n    event RelaxStatusUpdated(bool relaxed);\n    event RelaxThresholdUpdated(uint256 threshold, uint256 total);\n\n    function _initGuards(address[] memory _guards) internal {\n        require(guards.length == 0, \"guards already initiated\");\n        for (uint256 i = 0; i < _guards.length; i++) {\n            _addGuard(_guards[i]);\n        }\n        _setRelaxThreshold(guards.length);\n    }\n\n    function updateGuardState(GuardState _state) external {\n        GuardState current = guardStates[msg.sender];\n        require(current != GuardState.None, \"caller is not guard\");\n        require(current != _state, \"same with current state\");\n        guardStates[msg.sender] = _state;\n        if (_state == GuardState.Guarded) {\n            numRelaxedGuards--;\n        } else if (_state == GuardState.Relaxed) {\n            numRelaxedGuards++;\n        } else {\n            revert(\"invalid update\");\n        }\n        _updateRelaxed();\n        emit GuardUpdated(msg.sender, _state);\n    }\n\n    function addGuards(address[] calldata _accounts, bool _incrementThreshold) external onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addGuard(_accounts[i]);\n        }\n        if (_incrementThreshold) {\n            _setRelaxThreshold(relaxThreshold + _accounts.length);\n            _updateRelaxed();\n        }\n    }\n\n    function _addGuard(address _account) private {\n        require(guardStates[_account] == GuardState.None, \"account is already guard\");\n        guards.push(_account);\n        guardStates[_account] = GuardState.Guarded;\n        emit GuardUpdated(_account, GuardState.Guarded);\n    }\n\n    function removeGuards(address[] calldata _accounts, bool _decrementThreshold) external onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _removeGuard(_accounts[i]);\n        }\n        if (_decrementThreshold) {\n            _setRelaxThreshold(relaxThreshold - _accounts.length);\n        }\n        _updateRelaxed();\n    }\n\n    function _removeGuard(address _account) private {\n        GuardState state = guardStates[_account];\n        require(state != GuardState.None, \"account is not guard\");\n        if (state == GuardState.Relaxed) {\n            numRelaxedGuards--;\n        }\n        uint256 lastIndex = guards.length - 1;\n        for (uint256 i = 0; i < guards.length; i++) {\n            if (guards[i] == _account) {\n                if (i < lastIndex) {\n                    guards[i] = guards[lastIndex];\n                }\n                guards.pop();\n                guardStates[_account] = GuardState.None;\n                emit GuardUpdated(_account, GuardState.None);\n                return;\n            }\n        }\n        revert(\"guard not found\"); // this should never happen\n    }\n\n    function setRelaxThreshold(uint256 _threshold) external onlyOwner {\n        _setRelaxThreshold(_threshold);\n        _updateRelaxed();\n    }\n\n    function _setRelaxThreshold(uint256 _threshold) private {\n        require(_threshold <= guards.length, \"invalid threshold\");\n        relaxThreshold = _threshold;\n        emit RelaxThresholdUpdated(_threshold, guards.length);\n    }\n\n    function _updateRelaxed() private {\n        bool _relaxed = numRelaxedGuards >= relaxThreshold;\n        if (relaxed != _relaxed) {\n            relaxed = _relaxed;\n            emit RelaxStatusUpdated(relaxed);\n        }\n    }\n\n    function numGuards() public view returns (uint256) {\n        return guards.length;\n    }\n}\n"
    },
    "contracts/safeguard/sentinel/GuardedGovernor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.17;\n\nimport \"./Guard.sol\";\n\ninterface IBridge {\n    // delayed transfer\n    function setDelayPeriod(uint256 _period) external;\n\n    function delayPeriod() external view returns (uint256);\n\n    function setDelayThresholds(address[] calldata _tokens, uint256[] calldata _thresholds) external;\n\n    function delayThresholds(address _token) external view returns (uint256);\n\n    // volume control\n    function setEpochLength(uint256 _length) external;\n\n    function epochLength() external view returns (uint256);\n\n    function setEpochVolumeCaps(address[] calldata _tokens, uint256[] calldata _caps) external;\n\n    function epochVolumeCaps(address _token) external view returns (uint256);\n\n    // pool bridge\n    function setMinAdd(address[] calldata _tokens, uint256[] calldata _amounts) external;\n\n    function minAdd(address _token) external view returns (uint256);\n\n    function setMinSend(address[] calldata _tokens, uint256[] calldata _amounts) external;\n\n    function minSend(address _token) external view returns (uint256);\n\n    function setMaxSend(address[] calldata _tokens, uint256[] calldata _amounts) external;\n\n    function maxSend(address _token) external view returns (uint256);\n\n    function setNativeTokenTransferGas(uint256 _gasUsed) external;\n\n    function setMinimalMaxSlippage(uint32 _minimalMaxSlippage) external;\n\n    // peg bridge\n    function setMinDeposit(address[] calldata _tokens, uint256[] calldata _amounts) external;\n\n    function minDeposit(address _token) external view returns (uint256);\n\n    function setMaxDeposit(address[] calldata _tokens, uint256[] calldata _amounts) external;\n\n    function maxDeposit(address _token) external view returns (uint256);\n\n    function setMinBurn(address[] calldata _tokens, uint256[] calldata _amounts) external;\n\n    function minBurn(address _token) external view returns (uint256);\n\n    function setMaxBurn(address[] calldata _tokens, uint256[] calldata _amounts) external;\n\n    function maxBurn(address _token) external view returns (uint256);\n}\n\nabstract contract GuardedGovernor is Guard {\n    uint64 public numGovernors;\n    mapping(address => bool) public governors;\n\n    event GovernorUpdated(address account, bool added);\n\n    function _initGovernors(address[] memory _governors) internal {\n        require(numGovernors == 0, \"governors already initiated\");\n        for (uint256 i = 0; i < _governors.length; i++) {\n            _addGovernor(_governors[i]);\n        }\n    }\n\n    modifier onlyGovernor() {\n        require(isGovernor(msg.sender), \"Caller is not governor\");\n        _;\n    }\n\n    // delayed transfer\n\n    function setDelayPeriod(address _target, uint256 _period) external onlyGovernor {\n        if (!relaxed) {\n            uint256 current = IBridge(_target).delayPeriod();\n            require(_period > current, \"not in relax mode, can only increase period\");\n        }\n        IBridge(_target).setDelayPeriod(_period);\n    }\n\n    function setDelayThresholds(\n        address _target,\n        address[] calldata _tokens,\n        uint256[] calldata _thresholds\n    ) external onlyGovernor {\n        if (!relaxed) {\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                uint256 current = IBridge(_target).delayThresholds(_tokens[i]);\n                require(_thresholds[i] > current, \"not in relax mode, can only increase threshold\");\n            }\n        }\n        IBridge(_target).setDelayThresholds(_tokens, _thresholds);\n    }\n\n    // volume control\n\n    function setEpochLength(address _target, uint256 _length) external onlyGovernor {\n        if (!relaxed) {\n            uint256 current = IBridge(_target).epochLength();\n            require(_length > current, \"not in relax mode, can only increase length\");\n        }\n        IBridge(_target).setEpochLength(_length);\n    }\n\n    function setEpochVolumeCaps(\n        address _target,\n        address[] calldata _tokens,\n        uint256[] calldata _caps\n    ) external onlyGovernor {\n        if (!relaxed) {\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                uint256 current = IBridge(_target).epochVolumeCaps(_tokens[i]);\n                require(_caps[i] < current, \"not in relax mode, can only reduce cap\");\n            }\n        }\n        IBridge(_target).setEpochVolumeCaps(_tokens, _caps);\n    }\n\n    // pool bridge\n\n    function setMinAdd(\n        address _target,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external onlyGovernor {\n        if (!relaxed) {\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                uint256 current = IBridge(_target).minAdd(_tokens[i]);\n                require(_amounts[i] > current, \"not in relax mode, can only increase minAdd\");\n            }\n        }\n        IBridge(_target).setMinAdd(_tokens, _amounts);\n    }\n\n    function setMinSend(\n        address _target,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external onlyGovernor {\n        if (!relaxed) {\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                uint256 current = IBridge(_target).minSend(_tokens[i]);\n                require(_amounts[i] > current, \"not in relax mode, can only increase minSend\");\n            }\n        }\n        IBridge(_target).setMinSend(_tokens, _amounts);\n    }\n\n    function setMaxSend(\n        address _target,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external onlyGovernor {\n        if (!relaxed) {\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                uint256 current = IBridge(_target).maxSend(_tokens[i]);\n                require(_amounts[i] < current, \"not in relax mode, can only reduce maxSend\");\n            }\n        }\n        IBridge(_target).setMaxSend(_tokens, _amounts);\n    }\n\n    function setNativeTokenTransferGas(address _target, uint256 _gasUsed) external onlyGovernor {\n        IBridge(_target).setNativeTokenTransferGas(_gasUsed);\n    }\n\n    function setMinimalMaxSlippage(address _target, uint32 _minimalMaxSlippage) external onlyGovernor {\n        IBridge(_target).setMinimalMaxSlippage(_minimalMaxSlippage);\n    }\n\n    // peg bridge\n\n    function setMinDeposit(\n        address _target,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external onlyGovernor {\n        if (!relaxed) {\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                uint256 current = IBridge(_target).minDeposit(_tokens[i]);\n                require(_amounts[i] > current, \"not in relax mode, can only increase minDeposit\");\n            }\n        }\n        IBridge(_target).setMinDeposit(_tokens, _amounts);\n    }\n\n    function setMaxDeposit(\n        address _target,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external onlyGovernor {\n        if (!relaxed) {\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                uint256 current = IBridge(_target).maxDeposit(_tokens[i]);\n                require(_amounts[i] < current, \"not in relax mode, can only reduce maxDeposit\");\n            }\n        }\n        IBridge(_target).setMaxDeposit(_tokens, _amounts);\n    }\n\n    function setMinBurn(\n        address _target,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external onlyGovernor {\n        if (!relaxed) {\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                uint256 current = IBridge(_target).minBurn(_tokens[i]);\n                require(_amounts[i] > current, \"not in relax mode, can only increase minBurn\");\n            }\n        }\n        IBridge(_target).setMinBurn(_tokens, _amounts);\n    }\n\n    function setMaxBurn(\n        address _target,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external onlyGovernor {\n        if (!relaxed) {\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                uint256 current = IBridge(_target).maxBurn(_tokens[i]);\n                require(_amounts[i] < current, \"not in relax mode, can only reduce maxBurn\");\n            }\n        }\n        IBridge(_target).setMaxBurn(_tokens, _amounts);\n    }\n\n    function isGovernor(address _account) public view returns (bool) {\n        return governors[_account];\n    }\n\n    function addGovernors(address[] calldata _accounts) external onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addGovernor(_accounts[i]);\n        }\n    }\n\n    function _addGovernor(address _account) internal {\n        require(!isGovernor(_account), \"Account is already governor\");\n        governors[_account] = true;\n        numGovernors++;\n        emit GovernorUpdated(_account, true);\n    }\n\n    function removeGovernors(address[] calldata _accounts) external onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _removeGovernor(_accounts[i]);\n        }\n    }\n\n    function _removeGovernor(address _account) private {\n        require(isGovernor(_account), \"Account is not governor\");\n        governors[_account] = false;\n        numGovernors--;\n        emit GovernorUpdated(_account, false);\n    }\n\n    function renounceGovernor() external {\n        _removeGovernor(msg.sender);\n    }\n}\n"
    },
    "contracts/safeguard/sentinel/GuardedPauser.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.17;\n\nimport \"./Guard.sol\";\nimport \"../../libraries/Utils.sol\";\n\ninterface IPauser {\n    function pause() external;\n\n    function unpause() external;\n}\n\nabstract contract GuardedPauser is Guard {\n    enum PauserRole {\n        None,\n        Full,\n        PauseOnly\n    }\n\n    uint64 public numPausers;\n    mapping(address => PauserRole) public pausers;\n\n    event PauserUpdated(address account, PauserRole role);\n    event Failed(address target, string reason);\n\n    function _initPausers(address[] memory _pausers) internal {\n        require(numPausers == 0, \"pausers already initiated\");\n        for (uint256 i = 0; i < _pausers.length; i++) {\n            _addPauser(_pausers[i], PauserRole.Full);\n        }\n    }\n\n    function pause(address _target) public {\n        require(pausers[msg.sender] != PauserRole.None, \"invalid caller\");\n        IPauser(_target).pause();\n    }\n\n    function pause(address[] calldata _targets) public {\n        require(pausers[msg.sender] != PauserRole.None, \"invalid caller\");\n        require(_targets.length > 0, \"empty target list\");\n        bool hasSuccess;\n        for (uint256 i = 0; i < _targets.length; i++) {\n            (bool ok, bytes memory res) = address(_targets[i]).call(abi.encodeWithSelector(IPauser.pause.selector));\n            if (ok) {\n                hasSuccess = true;\n            } else {\n                emit Failed(_targets[i], Utils.getRevertMsg(res));\n            }\n        }\n        require(hasSuccess, \"pause failed for all targets\");\n    }\n\n    function unpause(address _target) public {\n        require(pausers[msg.sender] == PauserRole.Full, \"invalid caller\");\n        require(relaxed, \"not in relaxed mode\");\n        IPauser(_target).unpause();\n    }\n\n    function unpause(address[] calldata _targets) public {\n        require(pausers[msg.sender] == PauserRole.Full, \"invalid caller\");\n        require(relaxed, \"not in relaxed mode\");\n        require(_targets.length > 0, \"empty target list\");\n        bool hasSuccess;\n        for (uint256 i = 0; i < _targets.length; i++) {\n            (bool ok, bytes memory res) = address(_targets[i]).call(abi.encodeWithSelector(IPauser.unpause.selector));\n            if (ok) {\n                hasSuccess = true;\n            } else {\n                emit Failed(_targets[i], Utils.getRevertMsg(res));\n            }\n        }\n        require(hasSuccess, \"unpause failed for all targets\");\n    }\n\n    function addPausers(address[] calldata _accounts, PauserRole[] calldata _roles) external onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addPauser(_accounts[i], _roles[i]);\n        }\n    }\n\n    function _addPauser(address _account, PauserRole _role) private {\n        require(pausers[_account] == PauserRole.None, \"account is already pauser\");\n        require(_role == PauserRole.Full || _role == PauserRole.PauseOnly, \"invalid role\");\n        pausers[_account] = _role;\n        numPausers++;\n        emit PauserUpdated(_account, _role);\n    }\n\n    function removePausers(address[] calldata _accounts) external onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _removePauser(_accounts[i]);\n        }\n    }\n\n    function _removePauser(address _account) private {\n        require(pausers[_account] != PauserRole.None, \"account is not pauser\");\n        pausers[_account] = PauserRole.None;\n        numPausers--;\n        emit PauserUpdated(_account, PauserRole.None);\n    }\n\n    function setPausers(address[] calldata _accounts, PauserRole[] calldata _roles) external onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _setPauser(_accounts[i], _roles[i]);\n        }\n    }\n\n    function _setPauser(address _account, PauserRole _role) private {\n        require(pausers[_account] != PauserRole.None, \"account is not pauser\");\n        require(_role == PauserRole.Full || _role == PauserRole.PauseOnly, \"invalid role\");\n        pausers[_account] = _role;\n        emit PauserUpdated(_account, _role);\n    }\n}\n"
    },
    "contracts/safeguard/sentinel/Sentinel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.17;\n\nimport \"./GuardedPauser.sol\";\nimport \"./GuardedGovernor.sol\";\n\ncontract Sentinel is GuardedPauser, GuardedGovernor {\n    constructor(\n        address[] memory _guards,\n        address[] memory _pausers,\n        address[] memory _governors\n    ) {\n        _initGuards(_guards);\n        _initPausers(_pausers);\n        _initGovernors(_governors);\n    }\n\n    // This is to support upgradable deployment.\n    // Only to be called by Proxy via delegateCall as initOwner will require _owner is 0,\n    // so calling init on this contract directly will guarantee to fail\n    function init(\n        address[] memory _guards,\n        address[] memory _pausers,\n        address[] memory _governors\n    ) external {\n        initOwner();\n        _initGuards(_guards);\n        _initPausers(_pausers);\n        _initGovernors(_governors);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}